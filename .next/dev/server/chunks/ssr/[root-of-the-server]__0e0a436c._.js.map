{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///Users/youngjepark/Documents/GitHub/ThangBackend/components/PixelSnow.tsx"],"sourcesContent":["import { useEffect, useRef, useMemo, useCallback } from \"react\";\nimport {\n  Scene,\n  OrthographicCamera,\n  WebGLRenderer,\n  PlaneGeometry,\n  ShaderMaterial,\n  Mesh,\n  Vector2,\n  Vector3,\n  Color,\n} from \"three\";\n\nconst vertexShader = `\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n}\n`;\n\nconst fragmentShader = `\nprecision mediump float;\n\nuniform float uTime;\nuniform vec2 uResolution;\nuniform float uFlakeSize;\nuniform float uMinFlakeSize;\nuniform float uPixelResolution;\nuniform float uSpeed;\nuniform float uDepthFade;\nuniform float uFarPlane;\nuniform vec3 uColor;\nuniform float uBrightness;\nuniform float uGamma;\nuniform float uDensity;\nuniform float uVariant;\nuniform float uDirection;\n\n// Precomputed constants\n#define PI 3.14159265\n#define PI_OVER_6 0.5235988\n#define PI_OVER_3 1.0471976\n#define INV_SQRT3 0.57735027\n#define M1 1597334677U\n#define M2 3812015801U\n#define M3 3299493293U\n#define F0 2.3283064e-10\n\n// Optimized hash - inline multiplication\n#define hash(n) (n * (n ^ (n >> 15)))\n#define coord3(p) (uvec3(p).x * M1 ^ uvec3(p).y * M2 ^ uvec3(p).z * M3)\n\n// Precomputed camera basis vectors (normalized vec3(1,1,1), vec3(1,0,-1))\nconst vec3 camK = vec3(0.57735027, 0.57735027, 0.57735027);\nconst vec3 camI = vec3(0.70710678, 0.0, -0.70710678);\nconst vec3 camJ = vec3(-0.40824829, 0.81649658, -0.40824829);\n\n// Precomputed branch direction\nconst vec2 b1d = vec2(0.574, 0.819);\n\nvec3 hash3(uint n) {\n  uvec3 hashed = hash(n) * uvec3(1U, 511U, 262143U);\n  return vec3(hashed) * F0;\n}\n\nfloat snowflakeDist(vec2 p) {\n  float r = length(p);\n  float a = atan(p.y, p.x);\n  a = abs(mod(a + PI_OVER_6, PI_OVER_3) - PI_OVER_6);\n  vec2 q = r * vec2(cos(a), sin(a));\n  float dMain = max(abs(q.y), max(-q.x, q.x - 1.0));\n  float b1t = clamp(dot(q - vec2(0.4, 0.0), b1d), 0.0, 0.4);\n  float dB1 = length(q - vec2(0.4, 0.0) - b1t * b1d);\n  float b2t = clamp(dot(q - vec2(0.7, 0.0), b1d), 0.0, 0.25);\n  float dB2 = length(q - vec2(0.7, 0.0) - b2t * b1d);\n  return min(dMain, min(dB1, dB2)) * 10.0;\n}\n\nvoid main() {\n  // Precompute reciprocals to avoid division\n  float invPixelRes = 1.0 / uPixelResolution;\n  float pixelSize = max(1.0, floor(0.5 + uResolution.x * invPixelRes));\n  float invPixelSize = 1.0 / pixelSize;\n  \n  vec2 fragCoord = floor(gl_FragCoord.xy * invPixelSize);\n  vec2 res = uResolution * invPixelSize;\n  float invResX = 1.0 / res.x;\n\n  vec3 ray = normalize(vec3((fragCoord - res * 0.5) * invResX, 1.0));\n  ray = ray.x * camI + ray.y * camJ + ray.z * camK;\n\n  // Precompute time-based values\n  float timeSpeed = uTime * uSpeed;\n  float windX = cos(uDirection) * 0.4;\n  float windY = sin(uDirection) * 0.4;\n  vec3 camPos = (windX * camI + windY * camJ + 0.1 * camK) * timeSpeed;\n  vec3 pos = camPos;\n\n  // Precompute ray reciprocal for strides\n  vec3 absRay = max(abs(ray), vec3(0.001));\n  vec3 strides = 1.0 / absRay;\n  vec3 raySign = step(ray, vec3(0.0));\n  vec3 phase = fract(pos) * strides;\n  phase = mix(strides - phase, phase, raySign);\n\n  // Precompute for intersection test\n  float rayDotCamK = dot(ray, camK);\n  float invRayDotCamK = 1.0 / rayDotCamK;\n  float invDepthFade = 1.0 / uDepthFade;\n  float halfInvResX = 0.5 * invResX;\n  vec3 timeAnim = timeSpeed * 0.1 * vec3(7.0, 8.0, 5.0);\n\n  float t = 0.0;\n  for (int i = 0; i < 128; i++) {\n    if (t >= uFarPlane) break;\n    \n    vec3 fpos = floor(pos);\n    uint cellCoord = coord3(fpos);\n    float cellHash = hash3(cellCoord).x;\n\n    if (cellHash < uDensity) {\n      vec3 h = hash3(cellCoord);\n      \n      // Optimized flake position calculation\n      vec3 sinArg1 = fpos.yzx * 0.073;\n      vec3 sinArg2 = fpos.zxy * 0.27;\n      vec3 flakePos = 0.5 - 0.5 * cos(4.0 * sin(sinArg1) + 4.0 * sin(sinArg2) + 2.0 * h + timeAnim);\n      flakePos = flakePos * 0.8 + 0.1 + fpos;\n\n      float toIntersection = dot(flakePos - pos, camK) * invRayDotCamK;\n      \n      if (toIntersection > 0.0) {\n        vec3 testPos = pos + ray * toIntersection - flakePos;\n        float testX = dot(testPos, camI);\n        float testY = dot(testPos, camJ);\n        vec2 testUV = abs(vec2(testX, testY));\n        \n        float depth = dot(flakePos - camPos, camK);\n        float flakeSize = max(uFlakeSize, uMinFlakeSize * depth * halfInvResX);\n        \n        // Avoid branching with step functions where possible\n        float dist;\n        if (uVariant < 0.5) {\n          dist = max(testUV.x, testUV.y);\n        } else if (uVariant < 1.5) {\n          dist = length(testUV);\n        } else {\n          float invFlakeSize = 1.0 / flakeSize;\n          dist = snowflakeDist(vec2(testX, testY) * invFlakeSize) * flakeSize;\n        }\n\n        if (dist < flakeSize) {\n          float flakeSizeRatio = uFlakeSize / flakeSize;\n          float intensity = exp2(-(t + toIntersection) * invDepthFade) *\n                           min(1.0, flakeSizeRatio * flakeSizeRatio) * uBrightness;\n          gl_FragColor = vec4(uColor * pow(vec3(intensity), vec3(uGamma)), 1.0);\n          return;\n        }\n      }\n    }\n\n    float nextStep = min(min(phase.x, phase.y), phase.z);\n    vec3 sel = step(phase, vec3(nextStep));\n    phase = phase - nextStep + strides * sel;\n    t += nextStep;\n    pos = mix(pos + ray * nextStep, floor(pos + ray * nextStep + 0.5), sel);\n  }\n\n  gl_FragColor = vec4(0.0);\n}\n`;\n\ninterface PixelSnowProps {\n  color?: string;\n  flakeSize?: number;\n  minFlakeSize?: number;\n  pixelResolution?: number;\n  speed?: number;\n  depthFade?: number;\n  farPlane?: number;\n  brightness?: number;\n  gamma?: number;\n  density?: number;\n  variant?: \"square\" | \"round\" | \"snowflake\";\n  direction?: number;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nexport default function PixelSnow({\n  color = \"#ffffff\",\n  flakeSize = 0.01,\n  minFlakeSize = 1.25,\n  pixelResolution = 200,\n  speed = 1.25,\n  depthFade = 8,\n  farPlane = 20,\n  brightness = 1,\n  gamma = 0.4545,\n  density = 0.3,\n  variant = \"square\",\n  direction = 125,\n  className = \"\",\n  style = {},\n}: PixelSnowProps) {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const animationRef = useRef<number>(0);\n  const isVisibleRef = useRef(true);\n  const rendererRef = useRef<WebGLRenderer | null>(null);\n  const materialRef = useRef<ShaderMaterial | null>(null);\n  const resizeTimeoutRef = useRef<number | null>(null);\n\n  const getWindow = () =>\n    typeof globalThis !== \"undefined\" && (globalThis as any).window\n      ? ((globalThis as any).window as Window)\n      : undefined;\n\n  const variantValue = useMemo(() => {\n    return variant === \"round\" ? 1.0 : variant === \"snowflake\" ? 2.0 : 0.0;\n  }, [variant]);\n\n  const colorVector = useMemo(() => {\n    const threeColor = new Color(color);\n    return new Vector3(threeColor.r, threeColor.g, threeColor.b);\n  }, [color]);\n\n  const handleResize = useCallback(() => {\n    const win = getWindow();\n    if (resizeTimeoutRef.current) {\n      win?.clearTimeout(resizeTimeoutRef.current);\n    }\n    resizeTimeoutRef.current = win?.setTimeout(() => {\n      const container = containerRef.current;\n      const renderer = rendererRef.current;\n      const material = materialRef.current;\n      if (!container || !renderer || !material) return;\n\n      const w = container.offsetWidth;\n      const h = container.offsetHeight;\n      renderer.setSize(w, h);\n      material.uniforms.uResolution.value.set(w, h);\n    }, 100) as number | null;\n  }, []);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const win = getWindow();\n    if (!win) return;\n\n    const observer = new win.IntersectionObserver(\n      ([entry]) => {\n        isVisibleRef.current = entry.isIntersecting;\n      },\n      { threshold: 0 }\n    );\n\n    observer.observe(container);\n    return () => observer.disconnect();\n  }, []);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    const win = getWindow();\n    if (!container || !win) return;\n\n    const scene = new Scene();\n    const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    const renderer = new WebGLRenderer({\n      antialias: false,\n      alpha: true,\n      premultipliedAlpha: false,\n      powerPreference: \"high-performance\",\n      stencil: false,\n      depth: false,\n    });\n\n    renderer.setPixelRatio(Math.min(win.devicePixelRatio || 1, 2));\n    renderer.setSize(container.offsetWidth, container.offsetHeight);\n    renderer.setClearColor(0x000000, 0);\n    container.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    const material = new ShaderMaterial({\n      vertexShader,\n      fragmentShader,\n      uniforms: {\n        uTime: { value: 0 },\n        uResolution: {\n          value: new Vector2(container.offsetWidth, container.offsetHeight),\n        },\n        uFlakeSize: { value: flakeSize },\n        uMinFlakeSize: { value: minFlakeSize },\n        uPixelResolution: { value: pixelResolution },\n        uSpeed: { value: speed },\n        uDepthFade: { value: depthFade },\n        uFarPlane: { value: farPlane },\n        uColor: { value: colorVector.clone() },\n        uBrightness: { value: brightness },\n        uGamma: { value: gamma },\n        uDensity: { value: density },\n        uVariant: { value: variantValue },\n        uDirection: { value: (direction * Math.PI) / 180 },\n      },\n      transparent: true,\n    });\n    materialRef.current = material;\n\n    const geometry = new PlaneGeometry(2, 2);\n    scene.add(new Mesh(geometry, material));\n\n    win.addEventListener(\"resize\", handleResize);\n\n    const startTime = win.performance.now();\n    const animate = () => {\n      animationRef.current = win.requestAnimationFrame(animate);\n\n      if (isVisibleRef.current) {\n        material.uniforms.uTime.value =\n          (win.performance.now() - startTime) * 0.001;\n        renderer.render(scene, camera);\n      }\n    };\n    animate();\n\n    return () => {\n      win.cancelAnimationFrame(animationRef.current);\n      win.removeEventListener(\"resize\", handleResize);\n      if (resizeTimeoutRef.current) {\n        win.clearTimeout(resizeTimeoutRef.current);\n      }\n      if (container.contains(renderer.domElement)) {\n        container.removeChild(renderer.domElement);\n      }\n      renderer.dispose();\n      geometry.dispose();\n      material.dispose();\n      rendererRef.current = null;\n      materialRef.current = null;\n    };\n  }, [\n    brightness,\n    colorVector,\n    depthFade,\n    direction,\n    farPlane,\n    flakeSize,\n    handleResize,\n    minFlakeSize,\n    pixelResolution,\n    speed,\n    variantValue,\n  ]);\n\n  useEffect(() => {\n    const material = materialRef.current;\n    if (!material) return;\n\n    material.uniforms.uFlakeSize.value = flakeSize;\n    material.uniforms.uMinFlakeSize.value = minFlakeSize;\n    material.uniforms.uPixelResolution.value = pixelResolution;\n    material.uniforms.uSpeed.value = speed;\n    material.uniforms.uDepthFade.value = depthFade;\n    material.uniforms.uFarPlane.value = farPlane;\n    material.uniforms.uBrightness.value = brightness;\n    material.uniforms.uGamma.value = gamma;\n    material.uniforms.uDensity.value = density;\n    material.uniforms.uVariant.value = variantValue;\n    material.uniforms.uDirection.value = (direction * Math.PI) / 180;\n    material.uniforms.uColor.value.copy(colorVector);\n  }, [\n    flakeSize,\n    minFlakeSize,\n    pixelResolution,\n    speed,\n    depthFade,\n    farPlane,\n    brightness,\n    gamma,\n    density,\n    variantValue,\n    direction,\n    colorVector,\n  ]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={className}\n      style={{\n        position: \"absolute\",\n        inset: 0,\n        width: \"100%\",\n        height: \"100%\",\n        pointerEvents: \"none\",\n        ...style,\n      }}\n    />\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 386, "column": 0}, "map": {"version":3,"sources":["file:///Users/youngjepark/Documents/GitHub/ThangBackend/pages/learnmore.tsx"],"sourcesContent":["import PixelSnow from \"@/components/PixelSnow\";\n\nexport default function LearnMorePage() {\n  return (\n    <div style={styles.page}>\n      <div style={styles.fxLayer}>\n        <PixelSnow\n          color=\"#ffffff\"\n          flakeSize={0.01}\n          minFlakeSize={1.25}\n          pixelResolution={200}\n          speed={1.25}\n          density={0.3}\n          direction={125}\n          brightness={1}\n          variant=\"snowflake\"\n          style={{ opacity: 0.34 }}\n        />\n        <div style={styles.fxMask} />\n      </div>\n\n      <div style={styles.header}>\n        <p style={styles.kicker}>About Thang</p>\n        <h1 style={styles.title}>A world built for skill and squad play</h1>\n        <p style={styles.subtitle}>\n          Thang blends tight action combat with progression that respects your\n          time. Chase rare drops, craft signature builds, and jump into seasonal\n          content without losing what matters.\n        </p>\n      </div>\n\n      <div style={styles.section}>\n        <h3 style={styles.sectionTitle}>Combat that feels responsive</h3>\n        <p style={styles.sectionText}>\n          Every weapon class has unique timing, tells, and finishers. You can\n          dodge, parry, and chain abilities into ultimates that reward\n          precision.\n        </p>\n      </div>\n\n      <div style={styles.section}>\n        <h3 style={styles.sectionTitle}>Progress that sticks</h3>\n        <p style={styles.sectionText}>\n          Your account carries across devices. Seasonal ladders keep competition\n          fresh while preserving your core collection and cosmetics.\n        </p>\n      </div>\n\n      <div style={styles.section}>\n        <h3 style={styles.sectionTitle}>Built for co-op</h3>\n        <p style={styles.sectionText}>\n          Drop into dungeons with friends, trade loot, and take on rotating\n          world events. Cross-play lets your squad stay together on any\n          platform.\n        </p>\n      </div>\n\n      <div style={styles.section}>\n        <h3 style={styles.sectionTitle}>Roadmap</h3>\n        <ul style={styles.list}>\n          <li>Steam Deck optimization and controller-first UI</li>\n          <li>Seasonal raid tiers with leaderboard resets</li>\n          <li>New zones with biome-specific loot pools</li>\n          <li>Clan halls with shared crafting bonuses</li>\n        </ul>\n      </div>\n    </div>\n  );\n}\n\nconst styles: Record<string, React.CSSProperties> = {\n  page: {\n    minHeight: \"100vh\",\n    background:\n      \"radial-gradient(circle at 20% 20%, rgba(31, 97, 255, 0.08), transparent 28%),\" +\n      \"radial-gradient(circle at 80% 10%, rgba(118, 75, 162, 0.1), transparent 30%),\" +\n      \"#0b0d10\",\n    color: \"#e7e9ed\",\n    padding: \"40px 20px 80px\",\n    position: \"relative\",\n    overflow: \"hidden\",\n  },\n  fxLayer: {\n    position: \"absolute\",\n    inset: 0,\n    pointerEvents: \"none\",\n    zIndex: 0,\n  } as React.CSSProperties,\n  fxMask: {\n    position: \"absolute\",\n    inset: 0,\n    background:\n      \"linear-gradient(180deg, rgba(11,13,16,0.75) 0%, rgba(11,13,16,0.3) 40%, rgba(11,13,16,0.9) 100%)\",\n  } as React.CSSProperties,\n  header: {\n    maxWidth: \"900px\",\n    margin: \"0 auto 28px\",\n    position: \"relative\",\n    zIndex: 1,\n  },\n  kicker: {\n    margin: 0,\n    textTransform: \"uppercase\",\n    letterSpacing: \"0.08em\",\n    fontSize: \"12px\",\n    color: \"#8aa2ff\",\n  },\n  title: {\n    margin: \"6px 0 10px 0\",\n    fontSize: \"32px\",\n    letterSpacing: \"-0.02em\",\n  },\n  subtitle: {\n    margin: 0,\n    color: \"#c8cbd2\",\n    fontSize: \"15px\",\n    lineHeight: 1.6,\n  },\n  section: {\n    maxWidth: \"900px\",\n    margin: \"22px auto 0\",\n    background: \"#11141a\",\n    border: \"1px solid #1e232d\",\n    borderRadius: \"8px\",\n    padding: \"18px\",\n    boxShadow: \"0 10px 30px rgba(0,0,0,0.25)\",\n    position: \"relative\",\n    zIndex: 1,\n  } as React.CSSProperties,\n  sectionTitle: {\n    margin: \"0 0 8px 0\",\n    fontSize: \"18px\",\n  },\n  sectionText: {\n    margin: 0,\n    color: \"#c8cbd2\",\n    lineHeight: 1.5,\n    fontSize: \"14px\",\n  },\n  list: {\n    margin: \"8px 0 0 18px\",\n    color: \"#c8cbd2\",\n    lineHeight: 1.6,\n    fontSize: \"14px\",\n  } as React.CSSProperties,\n};\n"],"names":[],"mappings":";;;;;AAAA;;;;;;;AAEe,SAAS;IACtB,qBACE,qKAAC;QAAI,OAAO,OAAO,IAAI;;0BACrB,qKAAC;gBAAI,OAAO,OAAO,OAAO;;kCACxB,qKAAC,mKAAS;wBACR,OAAM;wBACN,WAAW;wBACX,cAAc;wBACd,iBAAiB;wBACjB,OAAO;wBACP,SAAS;wBACT,WAAW;wBACX,YAAY;wBACZ,SAAQ;wBACR,OAAO;4BAAE,SAAS;wBAAK;;;;;;kCAEzB,qKAAC;wBAAI,OAAO,OAAO,MAAM;;;;;;;;;;;;0BAG3B,qKAAC;gBAAI,OAAO,OAAO,MAAM;;kCACvB,qKAAC;wBAAE,OAAO,OAAO,MAAM;kCAAE;;;;;;kCACzB,qKAAC;wBAAG,OAAO,OAAO,KAAK;kCAAE;;;;;;kCACzB,qKAAC;wBAAE,OAAO,OAAO,QAAQ;kCAAE;;;;;;;;;;;;0BAO7B,qKAAC;gBAAI,OAAO,OAAO,OAAO;;kCACxB,qKAAC;wBAAG,OAAO,OAAO,YAAY;kCAAE;;;;;;kCAChC,qKAAC;wBAAE,OAAO,OAAO,WAAW;kCAAE;;;;;;;;;;;;0BAOhC,qKAAC;gBAAI,OAAO,OAAO,OAAO;;kCACxB,qKAAC;wBAAG,OAAO,OAAO,YAAY;kCAAE;;;;;;kCAChC,qKAAC;wBAAE,OAAO,OAAO,WAAW;kCAAE;;;;;;;;;;;;0BAMhC,qKAAC;gBAAI,OAAO,OAAO,OAAO;;kCACxB,qKAAC;wBAAG,OAAO,OAAO,YAAY;kCAAE;;;;;;kCAChC,qKAAC;wBAAE,OAAO,OAAO,WAAW;kCAAE;;;;;;;;;;;;0BAOhC,qKAAC;gBAAI,OAAO,OAAO,OAAO;;kCACxB,qKAAC;wBAAG,OAAO,OAAO,YAAY;kCAAE;;;;;;kCAChC,qKAAC;wBAAG,OAAO,OAAO,IAAI;;0CACpB,qKAAC;0CAAG;;;;;;0CACJ,qKAAC;0CAAG;;;;;;0CACJ,qKAAC;0CAAG;;;;;;0CACJ,qKAAC;0CAAG;;;;;;;;;;;;;;;;;;;;;;;;AAKd;AAEA,MAAM,SAA8C;IAClD,MAAM;QACJ,WAAW;QACX,YACE,kFACA,kFACA;QACF,OAAO;QACP,SAAS;QACT,UAAU;QACV,UAAU;IACZ;IACA,SAAS;QACP,UAAU;QACV,OAAO;QACP,eAAe;QACf,QAAQ;IACV;IACA,QAAQ;QACN,UAAU;QACV,OAAO;QACP,YACE;IACJ;IACA,QAAQ;QACN,UAAU;QACV,QAAQ;QACR,UAAU;QACV,QAAQ;IACV;IACA,QAAQ;QACN,QAAQ;QACR,eAAe;QACf,eAAe;QACf,UAAU;QACV,OAAO;IACT;IACA,OAAO;QACL,QAAQ;QACR,UAAU;QACV,eAAe;IACjB;IACA,UAAU;QACR,QAAQ;QACR,OAAO;QACP,UAAU;QACV,YAAY;IACd;IACA,SAAS;QACP,UAAU;QACV,QAAQ;QACR,YAAY;QACZ,QAAQ;QACR,cAAc;QACd,SAAS;QACT,WAAW;QACX,UAAU;QACV,QAAQ;IACV;IACA,cAAc;QACZ,QAAQ;QACR,UAAU;IACZ;IACA,aAAa;QACX,QAAQ;QACR,OAAO;QACP,YAAY;QACZ,UAAU;IACZ;IACA,MAAM;QACJ,QAAQ;QACR,OAAO;QACP,YAAY;QACZ,UAAU;IACZ;AACF"}}]
}